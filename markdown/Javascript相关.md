### 闭包

- 闭包就是能够读取其他函数内部变量的函数
- JS 中每个函数都有一个作用域，现在假设一个作用域链上有一大一小两个作用域，其中小的作用域中引用了大作用域中的变量，则在小作用域被销毁之前大作用域不能被销毁，这就是闭包
- 闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包

### 数据类型判断的方法？instanceof 判断复杂数据类型的原理是什么？toString()和 constructor 有了解过吗？

- 简单类型用 typeof，复杂类型用 instanceof。用 typeof 判断简单类型，除了 null 会返回 object，其他都会返回正确的结果，如果判断复杂类型通通返回 object。用 instanceof 可以检测某个实例是否是某个对象类型，如果用它来检测简单数据类型则始终返回 false，因为基本类型不是对象。
- instanceof 运算符 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
- 默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。例如

```
var o = new Object();
o.toString(); // returns [object Object]
```

- 可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。

```
var toString = Object.prototype.toString;

toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]

//Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
```

- 所有对象都会从它的原型上继承一个 constructor 属性，这个属性指向它的构造函数，可以利用这个属性判断数据类型。

### EventLoop 事件循环机制

- javascript 是一门单线程非阻塞的脚本语言，单线程意味着 javascript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。
- 事件循环是指主线程重复从消息队列中读取信息，执行的过程。实际上，主线程只会做一件事情，就是从消息队列里面取消息，执行消息，再取消息，再执行。
- 执行栈与消息队列

1. 主线程运行的时候会产生栈和堆
2. js 从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中
3. 当程序调用外部的 API 时，会将此类异步任务挂起，继续执行执行栈的任务。当异步任务返回结果后，再按照顺序排列到事件队列中。
4. 主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行栈中遇到异步任务，则继续将这个任务排列到事件队列中。
5. 主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个循环往复的过程就是“EventLoop”事件循环

### 说一下事件委托

- 事件委托指的是，不在事件的发生地(直接 dom)上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判定事件发生元素 dom 的类型，来做出不同的响应
- 举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。
- 好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。

### 事件流

- 事件捕获阶段：从 window 逐层向下传递到 目标元素，过程中遇到注册的捕获事件就会触发它
- 处于目标阶段：事件到达目标元素，触发目标元素上注册的事件
- 事件冒泡阶段：从目标元素向上传递到 window，过程中遇到注册的冒泡事件就会触发它

### 什么是发布-订阅模式

- 发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。
- 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。
  #### 实现思路
  - 创建一个对象
  - 在该对象上创建一个缓存列表（调度中心）
  - on 方法用来把函数 fn 都加到缓存列表中（订阅者注册事件到调度中心）
  - emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）
  - off 方法可以根据 event 值取消订阅（取消订阅）
  - once 方法只监听一次，调用完毕后删除缓存函数（订阅一次）
